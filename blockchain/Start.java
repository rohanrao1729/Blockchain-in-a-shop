import java.io.*;
import java.lang.*;
import java.util.*;
import java.security.*;
import java.sql.Timestamp;
import java.math.BigInteger; 
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest; 
import java.security.NoSuchAlgorithmException; 

public class Start{


    //current amt of money which dexter has
    //hardcoded but can be changed
	private static int ACT_AMOUNT=100000;
	//total amt which dexter has to get from his friends 
	private static int TO_GET_AMOUNT;
       
	public static void main(String[] args) throws NoSuchAlgorithmException{
	    try {
			System.setIn(new FileInputStream("fxt.txt"));
			System.setOut(new PrintStream(new FileOutputStream("fotxt.txt")));
		} catch (Exception e) {
			System.err.println("Error");
		}
		Scanner sc = new Scanner(System.in);
		// int t=sc.nextInt();
		// t=1;
		
		//trxPool is set of all transactions
		HashSet<Transaction> trxPool=new HashSet<>();

		//validTrxPool is set of all validated transactions
		HashSet<Transaction> validTrxPool=new HashSet<>();

		// take input from user or use dummy (example) transactions
		//either trans generated by transactionGen.py or give inp

		Transaction dummy0=new Transaction(5000,"rohan");
		Transaction dummy1=new Transaction(5000,"anushka");
		
		System.out.println("Enter the no of transactions in input file");
		System.out.println("format of transactions:");
		System.out.println("1 AMOUNT SENDER (here Dexter is receiver)");
		System.out.println("2 AMOUNT SENDER RECEIVER");
		System.out.println();
		
		int no_of_tr=Integer.parseInt(sc.next());
		// sc.nextLine();


		//taking transaction inputs

		for(int i=0;i<no_of_tr;i++){
			// System.out.println("Name :");
			int val=sc.nextInt();
			
			Transaction t;
			if(val==1){
				// System.out.println("Name :1");
				int amt=Integer.parseInt(sc.next());
               String nm=sc.next();
               t=new Transaction(amt,nm);

			}else{
				// System.out.println("Name :2");
				int amt=Integer.parseInt(sc.next());
               String nm=sc.next();
               String rec=sc.next();
               t=new Transaction(amt,nm,rec);

			}
			// String nm=sc.nextLine();
			// System.out.println("Amount: ");
			// int amt=sc.nextInt();

			

			trxPool.add(t); 
		}
		// trxPool.add(dummy0);
		// trxPool.add(dummy1);
		
		// getAllFailedTransactions(trxPool);

		// Handling the first block

		//GENESIS BLOCK
		Block gen=new Block();
		gen.prev=new Hash("abnacadabra");
		gen.merkelRoot=new Hash("abrsuhuahi");
		gen.curr=new Hash(gen);
        Block curr=new Block(new Hash(gen),gen);
        boolean flag=false;
        HashSet<Transaction> auxSet=new HashSet<>();
        for(Transaction tr:trxPool){
        	auxSet.add(tr);
        }
       
        //validate transactions and add it to blocks and also add
        //blocks to blockchain

        for(Transaction tx:auxSet){
        if(ifValidperformTransaction(tx)){
        	trxPool.remove(tx);validTrxPool.add(tx);
        	if(curr.addTransaction(tx)==false){
        		curr.merkelRoot=curr.merkelRootCalc(curr.li);
        		Hash hs=new Hash(curr);
        		curr.curr=hs;
        		curr=new Block(hs,curr);
        		flag=true;
        	}

        	if(flag){
        		curr.addTransaction(tx);
        		flag=false;
        	}
        }
		
	   }
       

	   BlockChain bc=new BlockChain(gen);
	   
	   // gen.printBlockInfo();
	   //Special case ie last block might have not filled its capacity
	   	if(curr.li.size()>0){
	   		curr.merkelRoot=curr.merkelRootCalc(curr.li);
	   	curr.curr=new Hash(curr);
	   	}
	   	// curr.printBlockInfo();



       //uncomment to see the following
       // getAllCompletedTransactions(validTrxPool);
	   // getAllFailedTransactions(trxPool)
	   bc.printAllTransactions(curr);
	}

	//utility function to getCurrentAmount which Dexter has
	private static int getCurrentAmount(){
		System.out.println("Dexter has Rs:"+ACT_AMOUNT);
		return ACT_AMOUNT;
	} 
    
    //check if the transaction is valid and return false if it fails
	private static boolean ifValidperformTransaction(Transaction t){
		boolean ans=true;
		if(t.receiver.equalsIgnoreCase("Dexter")){
             TO_GET_AMOUNT+=t.money;
		}else{
			if(t.sender.equalsIgnoreCase("Dexter")){
                   if(ACT_AMOUNT>=t.money){
                       ACT_AMOUNT-=t.money;
                   }else{
                   	ans=false;
                   	t.rejected=true;
                   }
			}else{
                
			}
		}
		return ans;
    }
    //prints all the transactions verified
    private static void getAllCompletedTransactions(HashSet<Transaction> hs){
       for(Transaction t:hs){
       	t.printTransaction();
       }
    }

    //prints all the transactions which failed in verification
    private static void getAllFailedTransactions(HashSet<Transaction> hs){
       for(Transaction t:hs){
       	t.printTransaction();
       }
    }


}

class Transaction{
	int money;
	String sender;
	String receiver="Dexter";
	Date d;
	Timestamp t;
	boolean rejected=false;
	Transaction(){

	}
	Transaction(int money,String sender){
        this.money=money;
        this.sender=sender;
        d=new Date();
        t=new Timestamp(d.getTime());
	}
	Transaction(int money,String sender,String receiver){
        this.money=money;
        this.sender=sender;
        this.receiver=receiver;
        d=new Date();
        t=new Timestamp(d.getTime());
	}

	//printts the timestamp of this transaction
	void printTimeStamp(){
		System.out.println(t);
	}
	//prints the transaction details
	void printTransaction(){
		System.out.println(this.sender+"->"+"sent Rs"+this.money+"to " +this.receiver);
		System.out.println("Transaction time:"+t);
		// printTimeStamp();
	}

}
class Block{
	List<Transaction> li;
	Hash prev;
	Hash curr;
	Hash merkelRoot;
	// BlockHeader bh;
	Block hsPtr;
	int confirmations=0;
	Timestamp tm;
	private static final int CAP=3;
	Block(){

	}
	Block(Hash prev,Block prevBl){
		this.prev=prev;
		this.hsPtr=prevBl;
		this.li=new ArrayList<>();
	}
	//adds the transaction to the current block if transaction is valid and 
	//current block is not full 
	//if the current block is full return false
	boolean addTransaction(Transaction t) throws NoSuchAlgorithmException{
            if(this.li.size()<CAP){
                this.li.add(t);
                return true;
            }else{
            	this.merkelRoot=merkelRootCalc(this.li);
            	Date d=new Date();
                this.tm=new Timestamp(d.getTime());
            	this.confirmations+=1;
            }
            return false;
	}
	//prints info of current block
    void printBlockInfo(){
    	System.out.println("Block Hash:"+this.curr.str);
    	System.out.println("Block merkelRoot:"+this.merkelRoot);
    	// System.out.println("Block Creation time:"+this.tm);
    	System.out.println("Block confirmations"+this.confirmations);

    }

    //implementation of merkelRoot calculation in O(nlogn)
	Hash merkelRootCalc(List<Transaction> li) throws NoSuchAlgorithmException{
          List<Hash> arr=new ArrayList<>();
          // to write ie hash of each transaction
          //arr.get(i) --->leaf hash

          if(li.size()==0)return new Hash("abndjkwjkjdwodwow");
          for(int i=0;i<li.size();i++){
          	arr.add(new Hash(li.get(i)));
          }
          while(arr.size()>1){
          	// System.out.println(arr);
          	if(arr.size()%2==1){
                arr.add(arr.get(arr.size()-1));
          	}
          	// System.out.println(arr);
          	// List<Hash> al=new ArrayList<>();
          	for(int i=0;i<arr.size();i+=2){
          		// al.add(hashComp(arr.get(i),arr.get(i+1)));
          		arr.set(i/2,hashComp(arr.get(i),arr.get(i+1)));
          	}
          	int n=arr.size();
          	for(int i=n-1;i>=n/2;i--)arr.remove(arr.size()-1);

          }
          return arr.get(0);
	}
	Hash hashComp(Hash A,Hash B) throws NoSuchAlgorithmException{
        
        StringBuilder sb=new StringBuilder();
        sb.append(A.str);
        sb.append(B.str);
        Hash ans=new Hash(sb.toString());
        return ans;
	}

}

class Hash{
	String str;
	Hash(){

	}
	// Hash(Object o){
	// 	str=String.valueOf(o.hashCode());
	// }
	Hash(String st) throws NoSuchAlgorithmException{
		str=HashAlgo.func(st);
	}
	Hash(Transaction tr) throws NoSuchAlgorithmException{
	   StringBuilder sb=new StringBuilder();
	   sb.append(tr.sender);
	   sb.append(tr.receiver);
	   sb.append(tr.money);
	   // System.out.println(sb);
       str=HashAlgo.func(sb.toString());
	}
	Hash(Block b) throws NoSuchAlgorithmException{
	  StringBuilder sb=new StringBuilder();
	  sb.append(b.prev.str);
	  sb.append(b.merkelRoot.str);

      str=HashAlgo.func(sb.toString());
	}
}
class HashAlgo{
	
	
	HashAlgo(){
       
	}
	

    public static String func(String str) throws NoSuchAlgorithmException{
    	return toHexString(getSHA(str));
    }
	public static byte[] getSHA(String input) throws NoSuchAlgorithmException
    { 
        // Static getInstance method is called with hashing SHA 
        MessageDigest md = MessageDigest.getInstance("SHA-256"); 
  
        // digest() method called 
        // to calculate message digest of an input 
        // and return array of byte
        return md.digest(input.getBytes(StandardCharsets.UTF_8)); 
    }
    
    public static String toHexString(byte[] hash)
    {
        // Convert byte array into signum representation 
        BigInteger number = new BigInteger(1, hash); 
  
        // Convert message digest into hex value 
        StringBuilder hexString = new StringBuilder(number.toString(16)); 
  
        // Pad with leading zeros
        while (hexString.length() < 32) 
        { 
            hexString.insert(0, '0'); 
        } 
  
        return hexString.toString(); 
    }

}
class BlockChain{
	Block genesis;
	static int height=0;
	
	BlockChain(Block b){
        // genesis= something to Do
	   this.genesis=b;
	}
	// prints all transactions of all the blocks before it including it 
	void printAllTransactions(Block b){
        Block tmp=b;
        int x=1;
        System.out.println("abs");
        while(tmp.equals(genesis)==false){
        	System.out.println("Block :"+x);
        	tmp.printBlockInfo();
        	x++;
        	for(Transaction t:tmp.li){
        		t.printTransaction();
        	}
        	tmp=tmp.hsPtr;
        }
	}
	//prints all transactions of the current block passed 
	void printTransactionBlock(Block b){
		b.printBlockInfo();
		for(Transaction t:b.li){
        		t.printTransaction();
        	}
	}

}


